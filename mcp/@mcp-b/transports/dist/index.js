import {JSONRPCMessageSchema}from'@modelcontextprotocol/sdk/types.js';var _=(n=>(n.START="start",n.STARTED="started",n.STOP="stop",n.STOPPED="stopped",n.PING="ping",n.PONG="pong",n.ERROR="error",n.LIST_TOOLS="list_tools",n.CALL_TOOL="call_tool",n.TOOL_LIST_UPDATED="tool_list_updated",n.TOOL_LIST_UPDATED_ACK="tool_list_updated_ack",n.PROCESS_DATA="process_data",n.SERVER_STARTED="server_started",n.SERVER_STOPPED="server_stopped",n.ERROR_FROM_NATIVE_HOST="error_from_native_host",n.CONNECT_NATIVE="connectNative",n.PING_NATIVE="ping_native",n.DISCONNECT_NATIVE="disconnect_native",n))(_||{}),m={NAME:"com.chromemcp.nativehost",DEFAULT_PORT:12306},E={NATIVE_CONNECTION_FAILED:"Failed to connect to native host",NATIVE_DISCONNECTED:"Native connection disconnected",SERVER_STATUS_LOAD_FAILED:"Failed to load server status",TOOL_EXECUTION_FAILED:"Tool execution failed",SERVER_STATUS_SAVE_FAILED:"Failed to save server status"},y={TOOL_EXECUTED:"Tool executed successfully",CONNECTION_ESTABLISHED:"Connection established",SERVER_STARTED:"Server started successfully",SERVER_STOPPED:"Server stopped successfully"},w={SERVER_STATUS:"serverStatus"},T={GET_SERVER_STATUS:"get_server_status",REFRESH_SERVER_STATUS:"refresh_server_status",SERVER_STATUS_CHANGED:"server_status_changed"},A=m.NAME;var a=class{_port;_extensionId;_portName;_messageHandler;_disconnectHandler;_isReconnecting=false;_reconnectAttempts=0;_reconnectTimer;_currentReconnectDelay;_isStarted=false;_isClosed=false;_autoReconnect;_maxReconnectAttempts;_reconnectDelay;_maxReconnectDelay;_reconnectBackoffMultiplier;onclose;onerror;onmessage;constructor(e={}){this._extensionId=e.extensionId,this._portName=e.portName||"mcp",this._autoReconnect=e.autoReconnect??true,this._maxReconnectAttempts=e.maxReconnectAttempts??10,this._reconnectDelay=e.reconnectDelay??1e3,this._maxReconnectDelay=e.maxReconnectDelay??3e4,this._reconnectBackoffMultiplier=e.reconnectBackoffMultiplier??1.5,this._currentReconnectDelay=this._reconnectDelay;}async start(){if(this._isStarted&&this._port){console.warn("ExtensionClientTransport already started! If using Client class, note that connect() calls start() automatically.");return}this._isStarted=true,this._isClosed=false,await this._connect();}async _connect(){return new Promise((e,t)=>{if(!chrome?.runtime?.connect){t(new Error("Chrome runtime API not available. This transport must be used in a Chrome extension context."));return}try{this._extensionId?this._port=chrome.runtime.connect(this._extensionId,{name:this._portName}):this._port=chrome.runtime.connect({name:this._portName}),this._messageHandler=o=>{try{if(o.type==="keep-alive")return;let s=JSONRPCMessageSchema.parse(o);this.onmessage?.(s);}catch(s){this.onerror?.(new Error(`Failed to parse message: ${s}`));}},this._disconnectHandler=()=>{this._cleanup(),this._isStarted&&!this._isClosed&&this._autoReconnect?this._scheduleReconnect():this.onclose?.();},this._port.onMessage.addListener(this._messageHandler),this._port.onDisconnect.addListener(this._disconnectHandler);let r=chrome.runtime.lastError;if(r){if(this._cleanup(),this._isReconnecting&&this._isStarted&&!this._isClosed&&this._autoReconnect){t(new Error(`Connection failed: ${r.message}`));return}t(new Error(`Connection failed: ${r.message}`));return}this._reconnectAttempts=0,this._currentReconnectDelay=this._reconnectDelay,this._isReconnecting=!1,e();}catch(r){t(r);}})}async send(e,t){if(!this._isStarted)throw new Error("Transport not started");if(this._isClosed)throw new Error("Transport is closed");if(!this._port)throw new Error("Not connected");try{this._port.postMessage(e);}catch(r){throw new Error(`Failed to send message: ${r}`)}}async close(){if(this._isClosed=true,this._isStarted=false,this._reconnectTimer&&(clearTimeout(this._reconnectTimer),this._reconnectTimer=void 0),this._port)try{this._port.disconnect();}catch{}this._cleanup(),this.onclose?.();}_cleanup(){this._port&&(this._messageHandler&&this._port.onMessage.removeListener(this._messageHandler),this._disconnectHandler&&this._port.onDisconnect.removeListener(this._disconnectHandler)),this._port=void 0;}_scheduleReconnect(){if(!(this._isReconnecting||this._isClosed||!this._isStarted)){if(this._isReconnecting=true,this._reconnectAttempts>=this._maxReconnectAttempts){console.error("Maximum reconnection attempts reached"),this._isReconnecting=false,this.onerror?.(new Error("Maximum reconnection attempts reached")),this.onclose?.();return}this._reconnectAttempts++,console.log(`Scheduling reconnection attempt ${this._reconnectAttempts}/${this._maxReconnectAttempts} in ${this._currentReconnectDelay}ms`),this._reconnectTimer=setTimeout(()=>{this._attemptReconnect();},this._currentReconnectDelay),this._currentReconnectDelay=Math.min(this._currentReconnectDelay*this._reconnectBackoffMultiplier,this._maxReconnectDelay);}}async _attemptReconnect(){if(!(this._isClosed||!this._isStarted))try{if(chrome?.runtime?.sendMessage)try{await chrome.runtime.sendMessage({type:"ping"});}catch{}await this._connect(),console.log("Reconnection successful"),this._isReconnecting=!1;}catch(e){console.error("Reconnection failed:",e),this._scheduleReconnect();}}};var c=class{_port;_started=false;_messageHandler;_disconnectHandler;_keepAliveTimer;_options;_connectionInfo;onclose;onerror;onmessage;constructor(e,t={}){this._port=e,this._options={keepAlive:t.keepAlive??true,keepAliveInterval:t.keepAliveInterval??1e3},this._connectionInfo={connectedAt:Date.now(),lastMessageAt:Date.now(),messageCount:0};}async start(){if(this._started)throw new Error("ExtensionServerTransport already started! If using Server class, note that connect() calls start() automatically.");if(!this._port)throw new Error("Port not available");this._started=true,this._messageHandler=e=>{try{if(this._connectionInfo.lastMessageAt=Date.now(),this._connectionInfo.messageCount++,e.type==="ping"){this._port.postMessage({type:"pong"});return}let t=JSONRPCMessageSchema.parse(e);this.onmessage?.(t);}catch(t){this.onerror?.(new Error(`Failed to parse message: ${t}`));}},this._disconnectHandler=()=>{console.log(`[ExtensionServerTransport] Client disconnected after ${Date.now()-this._connectionInfo.connectedAt}ms, processed ${this._connectionInfo.messageCount} messages`),this._cleanup(),this.onclose?.();},this._port.onMessage.addListener(this._messageHandler),this._port.onDisconnect.addListener(this._disconnectHandler),this._options.keepAlive&&this._startKeepAlive(),console.log(`[ExtensionServerTransport] Started with client: ${this._port.sender?.id||"unknown"}`);}async send(e,t){if(!this._started)throw new Error("Transport not started");if(!this._port)throw new Error("Not connected to client");try{this._port.postMessage(e);}catch(r){throw chrome.runtime.lastError||!this._port?(this._cleanup(),this.onclose?.(),new Error("Client disconnected")):new Error(`Failed to send message: ${r}`)}}async close(){if(this._started=false,this._port)try{this._port.disconnect();}catch{}this._cleanup(),this.onclose?.();}_cleanup(){this._keepAliveTimer&&(clearInterval(this._keepAliveTimer),this._keepAliveTimer=void 0),this._port&&(this._messageHandler&&this._port.onMessage.removeListener(this._messageHandler),this._disconnectHandler&&this._port.onDisconnect.removeListener(this._disconnectHandler));}_startKeepAlive(){this._keepAliveTimer||(console.log(`[ExtensionServerTransport] Starting keep-alive with ${this._options.keepAliveInterval}ms interval`),this._keepAliveTimer=setInterval(()=>{if(!this._port){this._stopKeepAlive();return}try{this._port.postMessage({type:"keep-alive",timestamp:Date.now()});}catch(e){console.error("[ExtensionServerTransport] Keep-alive failed:",e),this._stopKeepAlive();}},this._options.keepAliveInterval));}_stopKeepAlive(){this._keepAliveTimer&&(clearInterval(this._keepAliveTimer),this._keepAliveTimer=void 0);}getConnectionInfo(){return {...this._connectionInfo,uptime:Date.now()-this._connectionInfo.connectedAt,isConnected:!!this._port&&this._started}}};var l=class{_started=false;_targetOrigin;_channelId;_messageHandler;serverReadyPromise;_serverReadyResolve;_serverReadyReject;onclose;onerror;onmessage;constructor(e){if(!e.targetOrigin)throw new Error("targetOrigin must be explicitly set for security");this._targetOrigin=e.targetOrigin,this._channelId=e.channelId||"mcp-default";let{promise:t,resolve:r,reject:o}=Promise.withResolvers();this.serverReadyPromise=t,this._serverReadyResolve=()=>{r();},this._serverReadyReject=s=>{o(s);};}async start(){if(this._started)throw new Error("Transport already started");this._messageHandler=e=>{if(e.origin!==this._targetOrigin||e.data?.channel!==this._channelId||e.data?.type!=="mcp"||e.data?.direction!=="server-to-client")return;let t=e.data.payload;if(typeof t=="string"&&t==="mcp-server-ready"){this._serverReadyResolve();return}if(typeof t=="string"&&t==="mcp-server-stopped"){console.log("[TabClientTransport] Received mcp-server-stopped event, closing transport"),this.close();return}try{let r=JSONRPCMessageSchema.parse(t);this._serverReadyResolve(),this.onmessage?.(r);}catch(r){this.onerror?.(new Error(`Invalid message: ${r instanceof Error?r.message:String(r)}`));}},window.addEventListener("message",this._messageHandler),this._started=true,this.sendCheckReady();}sendCheckReady(){window.postMessage({channel:this._channelId,type:"mcp",direction:"client-to-server",payload:"mcp-check-ready"},this._targetOrigin);}async send(e){if(!this._started)throw new Error("Transport not started");await this.serverReadyPromise,window.postMessage({channel:this._channelId,type:"mcp",direction:"client-to-server",payload:e},this._targetOrigin);}async close(){this._messageHandler&&window.removeEventListener("message",this._messageHandler),this._serverReadyReject(new Error("Transport closed before server ready")),this._started=false,this.onclose?.();}};var p=class{_started=false;_allowedOrigins;_channelId;_messageHandler;_clientOrigin;onclose;onerror;onmessage;constructor(e){if(!e.allowedOrigins||e.allowedOrigins.length===0)throw new Error("At least one allowed origin must be specified");this._allowedOrigins=e.allowedOrigins,this._channelId=e.channelId||"mcp-default";}async start(){if(this._started)throw new Error("Transport already started");this._messageHandler=e=>{if(!this._allowedOrigins.includes(e.origin)&&!this._allowedOrigins.includes("*")||e.data?.channel!==this._channelId||e.data?.type!=="mcp"||e.data?.direction!=="client-to-server")return;this._clientOrigin=e.origin;let t=e.data.payload;if(typeof t=="string"&&t==="mcp-check-ready"){window.postMessage({channel:this._channelId,type:"mcp",direction:"server-to-client",payload:"mcp-server-ready"},this._clientOrigin);return}try{let r=JSONRPCMessageSchema.parse(t);this.onmessage?.(r);}catch(r){this.onerror?.(new Error(`Invalid message: ${r instanceof Error?r.message:String(r)}`));}},window.addEventListener("message",this._messageHandler),this._started=true,window.postMessage({channel:this._channelId,type:"mcp",direction:"server-to-client",payload:"mcp-server-ready"},"*");}async send(e){if(!this._started)throw new Error("Transport not started");if(!this._clientOrigin)throw new Error("No client connected");window.postMessage({channel:this._channelId,type:"mcp",direction:"server-to-client",payload:e},this._clientOrigin);}async close(){this._messageHandler&&window.removeEventListener("message",this._messageHandler),this._started=false,window.postMessage({channel:this._channelId,type:"mcp",direction:"server-to-client",payload:"mcp-server-stopped"},"*"),this.onclose?.();}};var d=class{_port;_extensionId;_portName;_messageHandler;_disconnectHandler;_isReconnecting=false;_reconnectAttempts=0;_reconnectTimer;_currentReconnectDelay;_isStarted=false;_isClosed=false;_autoReconnect;_maxReconnectAttempts;_reconnectDelay;_maxReconnectDelay;_reconnectBackoffMultiplier;onclose;onerror;onmessage;constructor(e={}){this._extensionId=e.extensionId,this._portName=e.portName||"mcp",this._autoReconnect=e.autoReconnect??true,this._maxReconnectAttempts=e.maxReconnectAttempts??10,this._reconnectDelay=e.reconnectDelay??1e3,this._maxReconnectDelay=e.maxReconnectDelay??3e4,this._reconnectBackoffMultiplier=e.reconnectBackoffMultiplier??1.5,this._currentReconnectDelay=this._reconnectDelay;}async start(){if(this._isStarted&&this._port){console.warn("UserScriptClientTransport already started! If using Client class, note that connect() calls start() automatically.");return}this._isStarted=true,this._isClosed=false,await this._connect();}async _connect(){return new Promise((e,t)=>{if(!chrome?.runtime?.connect){t(new Error("Chrome runtime API not available. This transport must be used in a Chrome MV3 User Script context."));return}try{this._extensionId?this._port=chrome.runtime.connect(this._extensionId,{name:this._portName}):this._port=chrome.runtime.connect({name:this._portName}),this._messageHandler=o=>{try{if(o.type==="keep-alive")return;let s=JSONRPCMessageSchema.parse(o);this.onmessage?.(s);}catch(s){this.onerror?.(new Error(`Failed to parse message: ${s}`));}},this._disconnectHandler=()=>{this._cleanup(),this._isStarted&&!this._isClosed&&this._autoReconnect?this._scheduleReconnect():this.onclose?.();},this._port.onMessage.addListener(this._messageHandler),this._port.onDisconnect.addListener(this._disconnectHandler);let r=chrome.runtime.lastError;if(r){if(this._cleanup(),this._isReconnecting&&this._isStarted&&!this._isClosed&&this._autoReconnect){t(new Error(`Connection failed: ${r.message}`));return}t(new Error(`Connection failed: ${r.message}`));return}this._reconnectAttempts=0,this._currentReconnectDelay=this._reconnectDelay,this._isReconnecting=!1,e();}catch(r){t(r);}})}async send(e,t){if(!this._isStarted)throw new Error("Transport not started");if(this._isClosed)throw new Error("Transport is closed");if(!this._port)throw new Error("Not connected");try{this._port.postMessage(e);}catch(r){throw new Error(`Failed to send message: ${r}`)}}async close(){if(this._isClosed=true,this._isStarted=false,this._reconnectTimer&&(clearTimeout(this._reconnectTimer),this._reconnectTimer=void 0),this._port)try{this._port.disconnect();}catch{}this._cleanup(),this.onclose?.();}_cleanup(){this._port&&(this._messageHandler&&this._port.onMessage.removeListener(this._messageHandler),this._disconnectHandler&&this._port.onDisconnect.removeListener(this._disconnectHandler)),this._port=void 0;}_scheduleReconnect(){if(!(this._isReconnecting||this._isClosed||!this._isStarted)){if(this._isReconnecting=true,this._reconnectAttempts>=this._maxReconnectAttempts){console.error("Maximum reconnection attempts reached"),this._isReconnecting=false,this.onerror?.(new Error("Maximum reconnection attempts reached")),this.onclose?.();return}this._reconnectAttempts++,console.log(`Scheduling reconnection attempt ${this._reconnectAttempts}/${this._maxReconnectAttempts} in ${this._currentReconnectDelay}ms`),this._reconnectTimer=setTimeout(()=>{this._attemptReconnect();},this._currentReconnectDelay),this._currentReconnectDelay=Math.min(this._currentReconnectDelay*this._reconnectBackoffMultiplier,this._maxReconnectDelay);}}async _attemptReconnect(){if(!(this._isClosed||!this._isStarted))try{if(chrome?.runtime?.sendMessage)try{await chrome.runtime.sendMessage({type:"ping"});}catch{}await this._connect(),console.log("Reconnection successful"),this._isReconnecting=!1;}catch(e){console.error("Reconnection failed:",e),this._scheduleReconnect();}}};var h=class{_port;_started=false;_messageHandler;_disconnectHandler;_keepAliveTimer;_options;_connectionInfo;onclose;onerror;onmessage;constructor(e,t={}){this._port=e,this._options={keepAlive:t.keepAlive??true,keepAliveInterval:t.keepAliveInterval??1e3},this._connectionInfo={connectedAt:Date.now(),lastMessageAt:Date.now(),messageCount:0};}async start(){if(this._started)throw new Error("UserScriptServerTransport already started! If using Server class, note that connect() calls start() automatically.");if(!this._port)throw new Error("Port not available");this._started=true,this._messageHandler=e=>{try{if(this._connectionInfo.lastMessageAt=Date.now(),this._connectionInfo.messageCount++,e.type==="ping"){this._port.postMessage({type:"pong"});return}let t=JSONRPCMessageSchema.parse(e);this.onmessage?.(t);}catch(t){this.onerror?.(new Error(`Failed to parse message: ${t}`));}},this._disconnectHandler=()=>{console.log(`[UserScriptServerTransport] Client disconnected after ${Date.now()-this._connectionInfo.connectedAt}ms, processed ${this._connectionInfo.messageCount} messages`),this._cleanup(),this.onclose?.();},this._port.onMessage.addListener(this._messageHandler),this._port.onDisconnect.addListener(this._disconnectHandler),this._options.keepAlive&&this._startKeepAlive(),console.log(`[UserScriptServerTransport] Started with client: ${this._port.sender?.id||"unknown"}`);}async send(e,t){if(!this._started)throw new Error("Transport not started");if(!this._port)throw new Error("Not connected to client");try{this._port.postMessage(e);}catch(r){throw chrome.runtime.lastError||!this._port?(this._cleanup(),this.onclose?.(),new Error("Client disconnected")):new Error(`Failed to send message: ${r}`)}}async close(){if(this._started=false,this._port)try{this._port.disconnect();}catch{}this._cleanup(),this.onclose?.();}_cleanup(){this._keepAliveTimer&&(clearInterval(this._keepAliveTimer),this._keepAliveTimer=void 0),this._port&&(this._messageHandler&&this._port.onMessage.removeListener(this._messageHandler),this._disconnectHandler&&this._port.onDisconnect.removeListener(this._disconnectHandler));}_startKeepAlive(){this._keepAliveTimer||(console.log(`[UserScriptServerTransport] Starting keep-alive with ${this._options.keepAliveInterval}ms interval`),this._keepAliveTimer=setInterval(()=>{if(!this._port){this._stopKeepAlive();return}try{this._port.postMessage({type:"keep-alive",timestamp:Date.now()});}catch(e){console.error("[UserScriptServerTransport] Keep-alive failed:",e),this._stopKeepAlive();}},this._options.keepAliveInterval));}_stopKeepAlive(){this._keepAliveTimer&&(clearInterval(this._keepAliveTimer),this._keepAliveTimer=void 0);}getConnectionInfo(){return {...this._connectionInfo,uptime:Date.now()-this._connectionInfo.connectedAt,isConnected:!!this._port&&this._started}}};export{T as BACKGROUND_MESSAGE_TYPES,E as ERROR_MESSAGES,a as ExtensionClientTransport,c as ExtensionServerTransport,A as HOST_NAME,m as NATIVE_HOST,_ as NativeMessageType,w as STORAGE_KEYS,y as SUCCESS_MESSAGES,l as TabClientTransport,p as TabServerTransport,d as UserScriptClientTransport,h as UserScriptServerTransport};//# sourceMappingURL=index.js.map
//# sourceMappingURL=index.js.map