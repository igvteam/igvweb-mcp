{"version":3,"sources":["../src/browser-types.ts","../src/ExtensionClientTransport.ts","../src/ExtensionServerTransport.ts","../src/TabClientTransport.ts","../src/TabServerTransport.ts","../src/UserScriptClientTransport.ts","../src/UserScriptServerTransport.ts"],"names":["NativeMessageType","NATIVE_HOST","ERROR_MESSAGES","SUCCESS_MESSAGES","STORAGE_KEYS","BACKGROUND_MESSAGE_TYPES","HOST_NAME","ExtensionClientTransport","options","resolve","reject","message","mcpMessage","JSONRPCMessageSchema","error","_options","ExtensionServerTransport","port","TabClientTransport","promise","reason","event","payload","TabServerTransport","UserScriptClientTransport","UserScriptServerTransport"],"mappings":"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","file":"index.js","sourcesContent":["import type { JSONRPCMessage } from '@modelcontextprotocol/sdk/types.js';\n\n/**\n * Unique identifier for an event in the event store\n */\nexport type EventId = string;\n\n/**\n * Unique identifier for a stream of events\n */\nexport type StreamId = string;\n\n/**\n * Options for connecting to an MCP server\n */\nexport interface MCPConnectOptions {\n  /**\n   * The event ID to resume from if reconnecting\n   */\n  resumeFrom?: EventId;\n}\n\n/**\n * Information about the MCP server\n */\nexport interface MCPServerInfo {\n  /**\n   * Unique identifier for this server instance\n   */\n  instanceId: string;\n  /**\n   * Whether the server maintains session state\n   */\n  stateful: boolean;\n  /**\n   * Whether the server has event storage enabled\n   */\n  hasEventStore: boolean;\n}\n\n/**\n * Event storage interface for accessing stored events\n */\nexport interface MCPEventStore {\n  /**\n   * Get stored events, optionally filtered by client and/or after a specific event\n   * @param clientId - Optional client ID to filter events\n   * @param afterEventId - Optional event ID to get events after\n   * @param limit - Maximum number of events to return (default: 100)\n   */\n  getEvents(clientId?: string, afterEventId?: EventId, limit?: number): StoredEvent[];\n\n  /**\n   * Get the ID of the last event, optionally for a specific client\n   * @param clientId - Optional client ID to filter by\n   */\n  getLastEventId(clientId?: string): EventId | null;\n\n  /**\n   * Clear stored events, optionally for a specific client\n   * @param clientId - Optional client ID to clear events for\n   */\n  clearEvents(clientId?: string): void;\n}\n\n/**\n * The MCP interface exposed on window for browser environments\n */\nexport interface MCPBrowserInterface {\n  /**\n   * Connect a client to the MCP server\n   * @param clientId - Unique identifier for the client\n   * @param options - Optional connection options\n   * @returns MessagePort for communication or null if connection fails\n   */\n  connect(clientId: string, options?: MCPConnectOptions): MessagePort | null;\n\n  /**\n   * Disconnect a client from the MCP server\n   * @param clientId - The client ID to disconnect\n   */\n  disconnect(clientId: string): void;\n\n  /**\n   * Terminate a client's session and clean up all associated resources\n   * @param clientId - The client ID to terminate\n   */\n  terminateSession?(clientId: string): void;\n\n  /**\n   * Check if the MCP server is available and running\n   */\n  isServerAvailable(): boolean;\n\n  /**\n   * Get information about the MCP server\n   */\n  getServerInfo(): MCPServerInfo;\n\n  /**\n   * Event storage access (only available in stateful mode with event store)\n   */\n  events?: MCPEventStore;\n}\n\n/**\n * Extended Window interface with MCP support\n */\nexport interface MCPWindow extends Window {\n  mcp?: MCPBrowserInterface;\n}\n\n/**\n * Message types for internal MCP communication\n */\nexport interface MCPServerInfoMessage {\n  type: 'mcp-server-info';\n  serverInstanceId: string;\n  serverSessionId?: string;\n  hasEventStore: boolean;\n  streamId: StreamId;\n}\n\nexport interface MCPEventMessage {\n  type: 'mcp-event';\n  eventId: EventId;\n  message: JSONRPCMessage;\n}\n\nexport interface MCPReplayEventMessage {\n  type: 'mcp-replay-event';\n  eventId: EventId;\n  message: JSONRPCMessage;\n}\n\n/**\n * Stored event with metadata for event sourcing\n */\nexport interface StoredEvent {\n  eventId: EventId;\n  streamId: StreamId;\n  message: JSONRPCMessage;\n  timestamp: number;\n  clientId: string;\n}\n\nexport enum NativeMessageType {\n  START = 'start',\n  STARTED = 'started',\n  STOP = 'stop',\n  STOPPED = 'stopped',\n  PING = 'ping',\n  PONG = 'pong',\n  ERROR = 'error',\n  LIST_TOOLS = 'list_tools',\n  CALL_TOOL = 'call_tool',\n  TOOL_LIST_UPDATED = 'tool_list_updated',\n  TOOL_LIST_UPDATED_ACK = 'tool_list_updated_ack',\n  PROCESS_DATA = 'process_data',\n\n  // Additional message types used in Chrome extension\n  SERVER_STARTED = 'server_started',\n  SERVER_STOPPED = 'server_stopped',\n  ERROR_FROM_NATIVE_HOST = 'error_from_native_host',\n  CONNECT_NATIVE = 'connectNative',\n  PING_NATIVE = 'ping_native',\n  DISCONNECT_NATIVE = 'disconnect_native',\n}\n\n/**\n * Chrome Extension Constants\n * Centralized configuration values and magic constants\n */\n\n// Native Host Configuration\nexport const NATIVE_HOST = {\n  NAME: 'com.chromemcp.nativehost',\n  DEFAULT_PORT: 12306,\n} as const;\n\n// Error Messages\nexport const ERROR_MESSAGES = {\n  NATIVE_CONNECTION_FAILED: 'Failed to connect to native host',\n  NATIVE_DISCONNECTED: 'Native connection disconnected',\n  SERVER_STATUS_LOAD_FAILED: 'Failed to load server status',\n  TOOL_EXECUTION_FAILED: 'Tool execution failed',\n  SERVER_STATUS_SAVE_FAILED: 'Failed to save server status',\n} as const;\n\n// Success Messages\nexport const SUCCESS_MESSAGES = {\n  TOOL_EXECUTED: 'Tool executed successfully',\n  CONNECTION_ESTABLISHED: 'Connection established',\n  SERVER_STARTED: 'Server started successfully',\n  SERVER_STOPPED: 'Server stopped successfully',\n} as const;\n\n// Storage Keys\nexport const STORAGE_KEYS = {\n  SERVER_STATUS: 'serverStatus',\n} as const;\n\n// Background script message types\nexport const BACKGROUND_MESSAGE_TYPES = {\n  GET_SERVER_STATUS: 'get_server_status',\n  REFRESH_SERVER_STATUS: 'refresh_server_status',\n  SERVER_STATUS_CHANGED: 'server_status_changed',\n} as const;\n\nexport const HOST_NAME = NATIVE_HOST.NAME;\n\n/**\n * Server status management interface\n */\nexport interface ServerStatus {\n  isRunning: boolean;\n  port?: number;\n  lastUpdated: number;\n}\n","import type {\n  Transport,\n  TransportSendOptions,\n} from '@modelcontextprotocol/sdk/shared/transport.js';\nimport { type JSONRPCMessage, JSONRPCMessageSchema } from '@modelcontextprotocol/sdk/types.js';\n\n/**\n * Configuration options for ExtensionClientTransport\n */\nexport interface ExtensionClientTransportOptions {\n  /**\n   * The extension ID to connect to (optional for same-extension connections)\n   */\n  extensionId?: string;\n\n  /**\n   * Port name for the connection\n   * Default: 'mcp'\n   */\n  portName?: string;\n\n  /**\n   * Enable automatic reconnection on disconnect\n   * Default: true\n   */\n  autoReconnect?: boolean;\n\n  /**\n   * Maximum number of reconnection attempts\n   * Default: 10\n   */\n  maxReconnectAttempts?: number;\n\n  /**\n   * Initial reconnection delay in milliseconds\n   * Default: 1000\n   */\n  reconnectDelay?: number;\n\n  /**\n   * Maximum reconnection delay in milliseconds\n   * Default: 30000\n   */\n  maxReconnectDelay?: number;\n\n  /**\n   * Reconnection backoff multiplier\n   * Default: 1.5\n   */\n  reconnectBackoffMultiplier?: number;\n}\n\n/**\n * Client transport for Chrome extensions using Port-based messaging.\n * This transport can be used in content scripts, popup scripts, or sidepanel scripts\n * to connect to a server running in the background service worker.\n *\n * Features automatic reconnection to handle background service worker lifecycle.\n */\nexport class ExtensionClientTransport implements Transport {\n  private _port?: chrome.runtime.Port;\n  private _extensionId?: string;\n  private _portName: string;\n  private _messageHandler?: (message: any) => void;\n  private _disconnectHandler?: () => void;\n  private _isReconnecting = false;\n  private _reconnectAttempts = 0;\n  private _reconnectTimer?: number;\n  private _currentReconnectDelay: number;\n  private _isStarted = false;\n  private _isClosed = false;\n\n  // Configuration\n  private _autoReconnect: boolean;\n  private _maxReconnectAttempts: number;\n  private _reconnectDelay: number;\n  private _maxReconnectDelay: number;\n  private _reconnectBackoffMultiplier: number;\n\n  onclose?: () => void;\n  onerror?: (error: Error) => void;\n  onmessage?: (message: JSONRPCMessage) => void;\n\n  constructor(options: ExtensionClientTransportOptions = {}) {\n    this._extensionId = options.extensionId;\n    this._portName = options.portName || 'mcp';\n    this._autoReconnect = options.autoReconnect ?? true;\n    this._maxReconnectAttempts = options.maxReconnectAttempts ?? 10;\n    this._reconnectDelay = options.reconnectDelay ?? 1000;\n    this._maxReconnectDelay = options.maxReconnectDelay ?? 30000;\n    this._reconnectBackoffMultiplier = options.reconnectBackoffMultiplier ?? 1.5;\n    this._currentReconnectDelay = this._reconnectDelay;\n  }\n\n  /**\n   * Starts the transport by connecting to the extension port\n   */\n  async start(): Promise<void> {\n    if (this._isStarted && this._port) {\n      console.warn(\n        'ExtensionClientTransport already started! If using Client class, note that connect() calls start() automatically.'\n      );\n      return;\n    }\n\n    this._isStarted = true;\n    this._isClosed = false;\n\n    await this._connect();\n  }\n\n  /**\n   * Connects to the extension port\n   */\n  private async _connect(): Promise<void> {\n    return new Promise((resolve, reject) => {\n      if (!chrome?.runtime?.connect) {\n        reject(\n          new Error(\n            'Chrome runtime API not available. This transport must be used in a Chrome extension context.'\n          )\n        );\n        return;\n      }\n\n      try {\n        // Connect to the extension\n        if (this._extensionId) {\n          this._port = chrome.runtime.connect(this._extensionId, {\n            name: this._portName,\n          });\n        } else {\n          this._port = chrome.runtime.connect({ name: this._portName });\n        }\n\n        // Set up message handler\n        this._messageHandler = (message: any) => {\n          try {\n            // Handle keep-alive messages\n            if (message.type === 'keep-alive') {\n              // Just acknowledge receipt, no need to propagate\n              return;\n            }\n\n            const mcpMessage = JSONRPCMessageSchema.parse(message);\n            this.onmessage?.(mcpMessage);\n          } catch (error) {\n            this.onerror?.(new Error(`Failed to parse message: ${error}`));\n          }\n        };\n\n        // Set up disconnect handler\n        this._disconnectHandler = () => {\n          this._cleanup();\n\n          // Only attempt reconnection if we're started and not manually closed\n          if (this._isStarted && !this._isClosed && this._autoReconnect) {\n            this._scheduleReconnect();\n          } else {\n            this.onclose?.();\n          }\n        };\n\n        this._port.onMessage.addListener(this._messageHandler);\n        this._port.onDisconnect.addListener(this._disconnectHandler);\n\n        // Check for immediate connection errors\n        const error = chrome.runtime.lastError;\n        if (error) {\n          this._cleanup();\n\n          // If we're reconnecting and hit an error, schedule another attempt\n          if (this._isReconnecting && this._isStarted && !this._isClosed && this._autoReconnect) {\n            reject(new Error(`Connection failed: ${error.message}`));\n            return;\n          }\n\n          reject(new Error(`Connection failed: ${error.message}`));\n          return;\n        }\n\n        // Connection successful\n        this._reconnectAttempts = 0;\n        this._currentReconnectDelay = this._reconnectDelay;\n        this._isReconnecting = false;\n\n        resolve();\n      } catch (error) {\n        reject(error);\n      }\n    });\n  }\n\n  /**\n   * Sends a message to the server\n   */\n  async send(message: JSONRPCMessage, _options?: TransportSendOptions): Promise<void> {\n    if (!this._isStarted) {\n      throw new Error('Transport not started');\n    }\n\n    if (this._isClosed) {\n      throw new Error('Transport is closed');\n    }\n\n    if (!this._port) {\n      throw new Error('Not connected');\n    }\n\n    try {\n      this._port.postMessage(message);\n    } catch (error) {\n      throw new Error(`Failed to send message: ${error}`);\n    }\n  }\n\n  /**\n   * Closes the transport\n   */\n  async close(): Promise<void> {\n    this._isClosed = true;\n    this._isStarted = false;\n\n    // Cancel any pending reconnection\n    if (this._reconnectTimer) {\n      clearTimeout(this._reconnectTimer);\n      this._reconnectTimer = undefined;\n    }\n\n    if (this._port) {\n      try {\n        this._port.disconnect();\n      } catch (error) {\n        // Port might already be disconnected\n      }\n    }\n\n    this._cleanup();\n    this.onclose?.();\n  }\n\n  /**\n   * Cleans up event listeners and references\n   */\n  private _cleanup(): void {\n    if (this._port) {\n      if (this._messageHandler) {\n        this._port.onMessage.removeListener(this._messageHandler);\n      }\n      if (this._disconnectHandler) {\n        this._port.onDisconnect.removeListener(this._disconnectHandler);\n      }\n    }\n    this._port = undefined;\n  }\n\n  /**\n   * Schedules a reconnection attempt\n   */\n  private _scheduleReconnect(): void {\n    if (this._isReconnecting || this._isClosed || !this._isStarted) {\n      return;\n    }\n\n    this._isReconnecting = true;\n\n    // Check if we've exceeded max attempts\n    if (this._reconnectAttempts >= this._maxReconnectAttempts) {\n      console.error('Maximum reconnection attempts reached');\n      this._isReconnecting = false;\n      this.onerror?.(new Error('Maximum reconnection attempts reached'));\n      this.onclose?.();\n      return;\n    }\n\n    this._reconnectAttempts++;\n\n    console.log(\n      `Scheduling reconnection attempt ${this._reconnectAttempts}/${this._maxReconnectAttempts} in ${this._currentReconnectDelay}ms`\n    );\n\n    this._reconnectTimer = setTimeout(() => {\n      this._attemptReconnect();\n    }, this._currentReconnectDelay) as unknown as number;\n\n    // Apply exponential backoff\n    this._currentReconnectDelay = Math.min(\n      this._currentReconnectDelay * this._reconnectBackoffMultiplier,\n      this._maxReconnectDelay\n    );\n  }\n\n  /**\n   * Attempts to reconnect to the extension\n   */\n  private async _attemptReconnect(): Promise<void> {\n    if (this._isClosed || !this._isStarted) {\n      return;\n    }\n\n    try {\n      // First, try to wake up the service worker by sending a message\n      if (chrome?.runtime?.sendMessage) {\n        try {\n          await chrome.runtime.sendMessage({ type: 'ping' });\n        } catch (error) {\n          // Service worker might not be ready yet\n        }\n      }\n\n      // Attempt to connect\n      await this._connect();\n\n      console.log('Reconnection successful');\n      this._isReconnecting = false;\n    } catch (error) {\n      console.error('Reconnection failed:', error);\n\n      // Schedule another attempt\n      this._scheduleReconnect();\n    }\n  }\n}\n","import type {\n  Transport,\n  TransportSendOptions,\n} from '@modelcontextprotocol/sdk/shared/transport.js';\nimport { type JSONRPCMessage, JSONRPCMessageSchema } from '@modelcontextprotocol/sdk/types.js';\n\n/**\n * Configuration options for ExtensionServerTransport\n */\nexport type ExtensionServerTransportOptions = {\n  /**\n   * Enable keep-alive mechanism to prevent service worker shutdown\n   * Default: true\n   */\n  keepAlive?: boolean;\n\n  /**\n   * Keep-alive interval in milliseconds\n   * Default: 25000 (25 seconds, less than Chrome's 30-second timeout)\n   */\n  keepAliveInterval?: number;\n};\n\n/**\n * Server transport for Chrome extensions using Port-based messaging.\n * This transport handles a single client connection through Chrome's port messaging API.\n * It should be used in the extension's background service worker.\n *\n * Features:\n * - Keep-alive mechanism to prevent service worker shutdown\n * - Graceful connection state management\n */\nexport class ExtensionServerTransport implements Transport {\n  private _port: chrome.runtime.Port;\n  private _started = false;\n  private _messageHandler?: (message: any, port: chrome.runtime.Port) => void;\n  private _disconnectHandler?: (port: chrome.runtime.Port) => void;\n  private _keepAliveTimer?: number;\n  private _options: ExtensionServerTransportOptions;\n  private _connectionInfo: {\n    connectedAt: number;\n    lastMessageAt: number;\n    messageCount: number;\n  };\n\n  onclose?: () => void;\n  onerror?: (error: Error) => void;\n  onmessage?: (message: JSONRPCMessage) => void;\n\n  constructor(port: chrome.runtime.Port, options: ExtensionServerTransportOptions = {}) {\n    this._port = port;\n    this._options = {\n      keepAlive: options.keepAlive ?? true,\n      keepAliveInterval: options.keepAliveInterval ?? 1000,\n    };\n    this._connectionInfo = {\n      connectedAt: Date.now(),\n      lastMessageAt: Date.now(),\n      messageCount: 0,\n    };\n  }\n\n  /**\n   * Starts the transport and begins handling messages\n   */\n  async start(): Promise<void> {\n    if (this._started) {\n      throw new Error(\n        'ExtensionServerTransport already started! If using Server class, note that connect() calls start() automatically.'\n      );\n    }\n\n    if (!this._port) {\n      throw new Error('Port not available');\n    }\n\n    this._started = true;\n\n    // Set up message handler\n    this._messageHandler = (message: any) => {\n      try {\n        // Update connection info\n        this._connectionInfo.lastMessageAt = Date.now();\n        this._connectionInfo.messageCount++;\n\n        // Handle ping messages for keep-alive\n        if (message.type === 'ping') {\n          this._port.postMessage({ type: 'pong' });\n          return;\n        }\n\n        const mcpMessage = JSONRPCMessageSchema.parse(message);\n        this.onmessage?.(mcpMessage);\n      } catch (error) {\n        this.onerror?.(new Error(`Failed to parse message: ${error}`));\n      }\n    };\n\n    // Set up disconnect handler\n    this._disconnectHandler = () => {\n      console.log(\n        `[ExtensionServerTransport] Client disconnected after ${Date.now() - this._connectionInfo.connectedAt}ms, processed ${this._connectionInfo.messageCount} messages`\n      );\n      this._cleanup();\n      this.onclose?.();\n    };\n\n    this._port.onMessage.addListener(this._messageHandler);\n    this._port.onDisconnect.addListener(this._disconnectHandler);\n\n    // Start keep-alive mechanism if enabled\n    if (this._options.keepAlive) {\n      this._startKeepAlive();\n    }\n\n    console.log(\n      `[ExtensionServerTransport] Started with client: ${this._port.sender?.id || 'unknown'}`\n    );\n  }\n\n  /**\n   * Sends a message to the client\n   */\n  async send(message: JSONRPCMessage, _options?: TransportSendOptions): Promise<void> {\n    if (!this._started) {\n      throw new Error('Transport not started');\n    }\n\n    if (!this._port) {\n      throw new Error('Not connected to client');\n    }\n\n    try {\n      this._port.postMessage(message);\n    } catch (error) {\n      // Check if the error is due to disconnection\n      if (chrome.runtime.lastError || !this._port) {\n        this._cleanup();\n        this.onclose?.();\n        throw new Error('Client disconnected');\n      }\n      throw new Error(`Failed to send message: ${error}`);\n    }\n  }\n\n  /**\n   * Closes the transport\n   */\n  async close(): Promise<void> {\n    this._started = false;\n\n    if (this._port) {\n      try {\n        this._port.disconnect();\n      } catch (error) {\n        // Port might already be disconnected\n      }\n    }\n\n    this._cleanup();\n    this.onclose?.();\n  }\n\n  /**\n   * Cleans up event listeners and references\n   */\n  private _cleanup(): void {\n    // Stop keep-alive timer\n    if (this._keepAliveTimer) {\n      clearInterval(this._keepAliveTimer);\n      this._keepAliveTimer = undefined;\n    }\n\n    if (this._port) {\n      if (this._messageHandler) {\n        this._port.onMessage.removeListener(this._messageHandler);\n      }\n      if (this._disconnectHandler) {\n        this._port.onDisconnect.removeListener(this._disconnectHandler);\n      }\n    }\n  }\n\n  /**\n   * Starts the keep-alive mechanism\n   */\n  private _startKeepAlive(): void {\n    if (this._keepAliveTimer) {\n      return;\n    }\n\n    console.log(\n      `[ExtensionServerTransport] Starting keep-alive with ${this._options.keepAliveInterval}ms interval`\n    );\n\n    this._keepAliveTimer = setInterval(() => {\n      if (!this._port) {\n        this._stopKeepAlive();\n        return;\n      }\n\n      try {\n        // Send a keep-alive ping\n        this._port.postMessage({ type: 'keep-alive', timestamp: Date.now() });\n      } catch (error) {\n        console.error('[ExtensionServerTransport] Keep-alive failed:', error);\n        this._stopKeepAlive();\n      }\n    }, this._options.keepAliveInterval!) as unknown as number;\n  }\n\n  /**\n   * Stops the keep-alive mechanism\n   */\n  private _stopKeepAlive(): void {\n    if (this._keepAliveTimer) {\n      clearInterval(this._keepAliveTimer);\n      this._keepAliveTimer = undefined;\n    }\n  }\n\n  /**\n   * Gets connection information\n   */\n  getConnectionInfo() {\n    return {\n      ...this._connectionInfo,\n      uptime: Date.now() - this._connectionInfo.connectedAt,\n      isConnected: !!this._port && this._started,\n    };\n  }\n}\n","// TabClientTransport.ts\n\nimport type { Transport } from '@modelcontextprotocol/sdk/shared/transport.js';\nimport { type JSONRPCMessage, JSONRPCMessageSchema } from '@modelcontextprotocol/sdk/types.js';\n\nexport interface TabClientTransportOptions {\n  targetOrigin: string; // Required for security\n  channelId?: string; // Optional channel name\n}\n\nexport class TabClientTransport implements Transport {\n  private _started = false;\n  private _targetOrigin: string;\n  private _channelId: string;\n  private _messageHandler?: (event: MessageEvent) => void;\n  public readonly serverReadyPromise: Promise<void>;\n  private _serverReadyResolve: () => void;\n  private _serverReadyReject: (reason: any) => void;\n  // private _retryInterval?: NodeJS.Timeout;\n\n  onclose?: () => void;\n  onerror?: (error: Error) => void;\n  onmessage?: (message: JSONRPCMessage) => void;\n\n  constructor(options: TabClientTransportOptions) {\n    if (!options.targetOrigin) {\n      throw new Error('targetOrigin must be explicitly set for security');\n    }\n    this._targetOrigin = options.targetOrigin;\n    this._channelId = options.channelId || 'mcp-default';\n\n    // Create the server ready promise in constructor so it's available immediately\n    const { promise, resolve, reject } = Promise.withResolvers<void>();\n    this.serverReadyPromise = promise;\n    this._serverReadyResolve = () => {\n      resolve();\n    };\n    this._serverReadyReject = (reason) => {\n      reject(reason);\n    };\n  }\n\n  async start(): Promise<void> {\n    if (this._started) {\n      throw new Error('Transport already started');\n    }\n\n    this._messageHandler = (event: MessageEvent) => {\n      // Security: validate origin\n      if (event.origin !== this._targetOrigin) {\n        return;\n      }\n\n      // Validate message structure\n      if (event.data?.channel !== this._channelId || event.data?.type !== 'mcp') {\n        return;\n      }\n\n      // Only process server-to-client messages to avoid processing own messages\n      if (event.data?.direction !== 'server-to-client') {\n        return;\n      }\n\n      const payload = event.data.payload;\n\n      // Handle server ready signal\n      if (typeof payload === 'string' && payload === 'mcp-server-ready') {\n        this._serverReadyResolve();\n        return;\n      }\n\n      // Handle server stopped signal\n      if (typeof payload === 'string' && payload === 'mcp-server-stopped') {\n        console.log('[TabClientTransport] Received mcp-server-stopped event, closing transport');\n        this.close();\n        return;\n      }\n\n      try {\n        const message = JSONRPCMessageSchema.parse(payload);\n        this._serverReadyResolve();\n        this.onmessage?.(message);\n      } catch (error) {\n        this.onerror?.(\n          new Error(`Invalid message: ${error instanceof Error ? error.message : String(error)}`)\n        );\n      }\n    };\n\n    window.addEventListener('message', this._messageHandler);\n    this._started = true;\n\n    // Send check-ready to prompt server if already started\n    this.sendCheckReady();\n  }\n\n  private sendCheckReady() {\n    window.postMessage(\n      {\n        channel: this._channelId,\n        type: 'mcp',\n        direction: 'client-to-server',\n        payload: 'mcp-check-ready',\n      },\n      this._targetOrigin\n    );\n  }\n\n  async send(message: JSONRPCMessage): Promise<void> {\n    if (!this._started) {\n      throw new Error('Transport not started');\n    }\n\n    // Await server ready before sending any JSON-RPC message\n    await this.serverReadyPromise;\n\n    window.postMessage(\n      {\n        channel: this._channelId,\n        type: 'mcp',\n        direction: 'client-to-server', // Mark as client-to-server message\n        payload: message,\n      },\n      this._targetOrigin\n    );\n  }\n\n  async close(): Promise<void> {\n    if (this._messageHandler) {\n      window.removeEventListener('message', this._messageHandler);\n    }\n\n    // Reject the server ready promise if it hasn't been resolved yet\n    this._serverReadyReject(new Error('Transport closed before server ready'));\n\n    this._started = false;\n    this.onclose?.();\n  }\n}\n","// TabServerTransport.ts\n\nimport type { Transport } from '@modelcontextprotocol/sdk/shared/transport.js';\nimport { type JSONRPCMessage, JSONRPCMessageSchema } from '@modelcontextprotocol/sdk/types.js';\n\nexport interface TabServerTransportOptions {\n  allowedOrigins: string[]; // Required for security\n  channelId?: string; // Optional channel name\n}\n\nexport class TabServerTransport implements Transport {\n  private _started = false;\n  private _allowedOrigins: string[];\n  private _channelId: string;\n  private _messageHandler?: (event: MessageEvent) => void;\n  private _clientOrigin?: string;\n\n  onclose?: () => void;\n  onerror?: (error: Error) => void;\n  onmessage?: (message: JSONRPCMessage) => void;\n\n  constructor(options: TabServerTransportOptions) {\n    if (!options.allowedOrigins || options.allowedOrigins.length === 0) {\n      throw new Error('At least one allowed origin must be specified');\n    }\n    this._allowedOrigins = options.allowedOrigins;\n    this._channelId = options.channelId || 'mcp-default';\n  }\n\n  async start(): Promise<void> {\n    if (this._started) {\n      throw new Error('Transport already started');\n    }\n\n    this._messageHandler = (event: MessageEvent) => {\n      // Security: validate origin\n      if (!this._allowedOrigins.includes(event.origin) && !this._allowedOrigins.includes('*')) {\n        return;\n      }\n\n      // Validate message structure\n      if (event.data?.channel !== this._channelId || event.data?.type !== 'mcp') {\n        return;\n      }\n\n      // Only process client-to-server messages to avoid processing own messages\n      if (event.data?.direction !== 'client-to-server') {\n        return;\n      }\n\n      // Store client origin for responses\n      this._clientOrigin = event.origin;\n\n      const payload = event.data.payload;\n\n      if (typeof payload === 'string' && payload === 'mcp-check-ready') {\n        // Respond with server ready\n        window.postMessage(\n          {\n            channel: this._channelId,\n            type: 'mcp',\n            direction: 'server-to-client',\n            payload: 'mcp-server-ready',\n          },\n          this._clientOrigin\n        );\n        return;\n      }\n\n      try {\n        const message = JSONRPCMessageSchema.parse(payload);\n        this.onmessage?.(message);\n      } catch (error) {\n        this.onerror?.(\n          new Error(`Invalid message: ${error instanceof Error ? error.message : String(error)}`)\n        );\n      }\n    };\n\n    window.addEventListener('message', this._messageHandler);\n    this._started = true;\n\n    // Broadcast server ready to all allowed origins\n    window.postMessage(\n      {\n        channel: this._channelId,\n        type: 'mcp',\n        direction: 'server-to-client',\n        payload: 'mcp-server-ready',\n      },\n      '*'\n    );\n  }\n\n  async send(message: JSONRPCMessage): Promise<void> {\n    if (!this._started) {\n      throw new Error('Transport not started');\n    }\n\n    if (!this._clientOrigin) {\n      throw new Error('No client connected');\n    }\n\n    window.postMessage(\n      {\n        channel: this._channelId,\n        type: 'mcp',\n        direction: 'server-to-client', // Mark as server-to-client message\n        payload: message,\n      },\n      this._clientOrigin\n    );\n  }\n\n  async close(): Promise<void> {\n    if (this._messageHandler) {\n      window.removeEventListener('message', this._messageHandler);\n    }\n    this._started = false;\n\n    // Post message to notify content scripts that the MCP server has stopped\n    window.postMessage(\n      {\n        channel: this._channelId,\n        type: 'mcp',\n        direction: 'server-to-client',\n        payload: 'mcp-server-stopped',\n      },\n      '*'\n    );\n\n    this.onclose?.();\n  }\n}\n","import type {\n  Transport,\n  TransportSendOptions,\n} from '@modelcontextprotocol/sdk/shared/transport.js';\nimport { type JSONRPCMessage, JSONRPCMessageSchema } from '@modelcontextprotocol/sdk/types.js';\n\n/**\n * Configuration options for UserScriptClientTransport\n */\nexport interface UserScriptClientTransportOptions {\n  /**\n   * The extension ID to connect to (optional for same-extension connections)\n   */\n  extensionId?: string;\n\n  /**\n   * Port name for the connection\n   * Default: 'mcp'\n   */\n  portName?: string;\n\n  /**\n   * Enable automatic reconnection on disconnect\n   * Default: true\n   */\n  autoReconnect?: boolean;\n\n  /**\n   * Maximum number of reconnection attempts\n   * Default: 10\n   */\n  maxReconnectAttempts?: number;\n\n  /**\n   * Initial reconnection delay in milliseconds\n   * Default: 1000\n   */\n  reconnectDelay?: number;\n\n  /**\n   * Maximum reconnection delay in milliseconds\n   * Default: 30000\n   */\n  maxReconnectDelay?: number;\n\n  /**\n   * Reconnection backoff multiplier\n   * Default: 1.5\n   */\n  reconnectBackoffMultiplier?: number;\n}\n\n/**\n * Client transport for Chrome MV3 User Scripts using Port-based messaging.\n * This transport can be used inside a User Script context to connect to the\n * extension's background service worker. On the extension side, connections\n * are received via chrome.runtime.onUserScriptConnect.\n *\n * Features automatic reconnection to handle background service worker lifecycle.\n */\nexport class UserScriptClientTransport implements Transport {\n  private _port?: chrome.runtime.Port;\n  private _extensionId?: string;\n  private _portName: string;\n  private _messageHandler?: (message: any) => void;\n  private _disconnectHandler?: () => void;\n  private _isReconnecting = false;\n  private _reconnectAttempts = 0;\n  private _reconnectTimer?: number;\n  private _currentReconnectDelay: number;\n  private _isStarted = false;\n  private _isClosed = false;\n\n  // Configuration\n  private _autoReconnect: boolean;\n  private _maxReconnectAttempts: number;\n  private _reconnectDelay: number;\n  private _maxReconnectDelay: number;\n  private _reconnectBackoffMultiplier: number;\n\n  onclose?: () => void;\n  onerror?: (error: Error) => void;\n  onmessage?: (message: JSONRPCMessage) => void;\n\n  constructor(options: UserScriptClientTransportOptions = {}) {\n    this._extensionId = options.extensionId;\n    this._portName = options.portName || 'mcp';\n    this._autoReconnect = options.autoReconnect ?? true;\n    this._maxReconnectAttempts = options.maxReconnectAttempts ?? 10;\n    this._reconnectDelay = options.reconnectDelay ?? 1000;\n    this._maxReconnectDelay = options.maxReconnectDelay ?? 30000;\n    this._reconnectBackoffMultiplier = options.reconnectBackoffMultiplier ?? 1.5;\n    this._currentReconnectDelay = this._reconnectDelay;\n  }\n\n  /**\n   * Starts the transport by connecting to the extension port\n   */\n  async start(): Promise<void> {\n    if (this._isStarted && this._port) {\n      console.warn(\n        'UserScriptClientTransport already started! If using Client class, note that connect() calls start() automatically.'\n      );\n      return;\n    }\n\n    this._isStarted = true;\n    this._isClosed = false;\n\n    await this._connect();\n  }\n\n  /**\n   * Connects to the extension port\n   */\n  private async _connect(): Promise<void> {\n    return new Promise((resolve, reject) => {\n      if (!chrome?.runtime?.connect) {\n        reject(\n          new Error(\n            'Chrome runtime API not available. This transport must be used in a Chrome MV3 User Script context.'\n          )\n        );\n        return;\n      }\n\n      try {\n        // Connect to the extension. From a user script, this triggers onUserScriptConnect on the extension side.\n        if (this._extensionId) {\n          this._port = chrome.runtime.connect(this._extensionId, {\n            name: this._portName,\n          });\n        } else {\n          this._port = chrome.runtime.connect({ name: this._portName });\n        }\n\n        // Set up message handler\n        this._messageHandler = (message: any) => {\n          try {\n            // Handle keep-alive messages\n            if ((message as any).type === 'keep-alive') {\n              return;\n            }\n\n            const mcpMessage = JSONRPCMessageSchema.parse(message);\n            this.onmessage?.(mcpMessage);\n          } catch (error) {\n            this.onerror?.(new Error(`Failed to parse message: ${error}`));\n          }\n        };\n\n        // Set up disconnect handler\n        this._disconnectHandler = () => {\n          this._cleanup();\n\n          // Only attempt reconnection if we're started and not manually closed\n          if (this._isStarted && !this._isClosed && this._autoReconnect) {\n            this._scheduleReconnect();\n          } else {\n            this.onclose?.();\n          }\n        };\n\n        this._port.onMessage.addListener(this._messageHandler);\n        this._port.onDisconnect.addListener(this._disconnectHandler);\n\n        // Check for immediate connection errors\n        const error = chrome.runtime.lastError;\n        if (error) {\n          this._cleanup();\n\n          // If we're reconnecting and hit an error, schedule another attempt\n          if (this._isReconnecting && this._isStarted && !this._isClosed && this._autoReconnect) {\n            reject(new Error(`Connection failed: ${error.message}`));\n            return;\n          }\n\n          reject(new Error(`Connection failed: ${error.message}`));\n          return;\n        }\n\n        // Connection successful\n        this._reconnectAttempts = 0;\n        this._currentReconnectDelay = this._reconnectDelay;\n        this._isReconnecting = false;\n\n        resolve();\n      } catch (error) {\n        reject(error);\n      }\n    });\n  }\n\n  /**\n   * Sends a message to the server\n   */\n  async send(message: JSONRPCMessage, _options?: TransportSendOptions): Promise<void> {\n    if (!this._isStarted) {\n      throw new Error('Transport not started');\n    }\n\n    if (this._isClosed) {\n      throw new Error('Transport is closed');\n    }\n\n    if (!this._port) {\n      throw new Error('Not connected');\n    }\n\n    try {\n      this._port.postMessage(message);\n    } catch (error) {\n      throw new Error(`Failed to send message: ${error}`);\n    }\n  }\n\n  /**\n   * Closes the transport\n   */\n  async close(): Promise<void> {\n    this._isClosed = true;\n    this._isStarted = false;\n\n    // Cancel any pending reconnection\n    if (this._reconnectTimer) {\n      clearTimeout(this._reconnectTimer);\n      this._reconnectTimer = undefined;\n    }\n\n    if (this._port) {\n      try {\n        this._port.disconnect();\n      } catch (error) {\n        // Port might already be disconnected\n      }\n    }\n\n    this._cleanup();\n    this.onclose?.();\n  }\n\n  /**\n   * Cleans up event listeners and references\n   */\n  private _cleanup(): void {\n    if (this._port) {\n      if (this._messageHandler) {\n        this._port.onMessage.removeListener(this._messageHandler);\n      }\n      if (this._disconnectHandler) {\n        this._port.onDisconnect.removeListener(this._disconnectHandler);\n      }\n    }\n    this._port = undefined;\n  }\n\n  /**\n   * Schedules a reconnection attempt\n   */\n  private _scheduleReconnect(): void {\n    if (this._isReconnecting || this._isClosed || !this._isStarted) {\n      return;\n    }\n\n    this._isReconnecting = true;\n\n    // Check if we've exceeded max attempts\n    if (this._reconnectAttempts >= this._maxReconnectAttempts) {\n      console.error('Maximum reconnection attempts reached');\n      this._isReconnecting = false;\n      this.onerror?.(new Error('Maximum reconnection attempts reached'));\n      this.onclose?.();\n      return;\n    }\n\n    this._reconnectAttempts++;\n\n    console.log(\n      `Scheduling reconnection attempt ${this._reconnectAttempts}/${this._maxReconnectAttempts} in ${this._currentReconnectDelay}ms`\n    );\n\n    this._reconnectTimer = setTimeout(() => {\n      this._attemptReconnect();\n    }, this._currentReconnectDelay) as unknown as number;\n\n    // Apply exponential backoff\n    this._currentReconnectDelay = Math.min(\n      this._currentReconnectDelay * this._reconnectBackoffMultiplier,\n      this._maxReconnectDelay\n    );\n  }\n\n  /**\n   * Attempts to reconnect to the extension\n   */\n  private async _attemptReconnect(): Promise<void> {\n    if (this._isClosed || !this._isStarted) {\n      return;\n    }\n\n    try {\n      // First, try to wake up the service worker by sending a message\n      if (chrome?.runtime?.sendMessage) {\n        try {\n          await chrome.runtime.sendMessage({ type: 'ping' });\n        } catch (error) {\n          // Service worker might not be ready yet\n        }\n      }\n\n      // Attempt to connect\n      await this._connect();\n\n      console.log('Reconnection successful');\n      this._isReconnecting = false;\n    } catch (error) {\n      console.error('Reconnection failed:', error);\n\n      // Schedule another attempt\n      this._scheduleReconnect();\n    }\n  }\n}\n","import type {\n  Transport,\n  TransportSendOptions,\n} from '@modelcontextprotocol/sdk/shared/transport.js';\nimport { type JSONRPCMessage, JSONRPCMessageSchema } from '@modelcontextprotocol/sdk/types.js';\n\n/**\n * Configuration options for UserScriptServerTransport\n */\nexport type UserScriptServerTransportOptions = {\n  /**\n   * Enable keep-alive mechanism to prevent service worker shutdown\n   * Default: true\n   */\n  keepAlive?: boolean;\n\n  /**\n   * Keep-alive interval in milliseconds\n   * Default: 25000 (25 seconds, less than Chrome's 30-second timeout)\n   */\n  keepAliveInterval?: number;\n};\n\n/**\n * Server transport for Chrome MV3 User Scripts using Port-based messaging.\n * This transport handles a single client connection through Chrome's port\n * messaging API. It should be used in the extension's background service\n * worker. Connections are initiated from User Scripts via chrome.runtime.connect\n * and received here via chrome.runtime.onUserScriptConnect.\n *\n * Features:\n * - Keep-alive mechanism to prevent service worker shutdown\n * - Graceful connection state management\n */\nexport class UserScriptServerTransport implements Transport {\n  private _port: chrome.runtime.Port;\n  private _started = false;\n  private _messageHandler?: (message: any, port: chrome.runtime.Port) => void;\n  private _disconnectHandler?: (port: chrome.runtime.Port) => void;\n  private _keepAliveTimer?: number;\n  private _options: UserScriptServerTransportOptions;\n  private _connectionInfo: {\n    connectedAt: number;\n    lastMessageAt: number;\n    messageCount: number;\n  };\n\n  onclose?: () => void;\n  onerror?: (error: Error) => void;\n  onmessage?: (message: JSONRPCMessage) => void;\n\n  constructor(port: chrome.runtime.Port, options: UserScriptServerTransportOptions = {}) {\n    this._port = port;\n    this._options = {\n      keepAlive: options.keepAlive ?? true,\n      keepAliveInterval: options.keepAliveInterval ?? 1000,\n    };\n    this._connectionInfo = {\n      connectedAt: Date.now(),\n      lastMessageAt: Date.now(),\n      messageCount: 0,\n    };\n  }\n\n  /**\n   * Starts the transport and begins handling messages\n   */\n  async start(): Promise<void> {\n    if (this._started) {\n      throw new Error(\n        'UserScriptServerTransport already started! If using Server class, note that connect() calls start() automatically.'\n      );\n    }\n\n    if (!this._port) {\n      throw new Error('Port not available');\n    }\n\n    this._started = true;\n\n    // Set up message handler\n    this._messageHandler = (message: any) => {\n      try {\n        // Update connection info\n        this._connectionInfo.lastMessageAt = Date.now();\n        this._connectionInfo.messageCount++;\n\n        // Handle ping messages for keep-alive\n        if ((message as any).type === 'ping') {\n          this._port.postMessage({ type: 'pong' });\n          return;\n        }\n\n        const mcpMessage = JSONRPCMessageSchema.parse(message);\n        this.onmessage?.(mcpMessage);\n      } catch (error) {\n        this.onerror?.(new Error(`Failed to parse message: ${error}`));\n      }\n    };\n\n    // Set up disconnect handler\n    this._disconnectHandler = () => {\n      console.log(\n        `[UserScriptServerTransport] Client disconnected after ${Date.now() - this._connectionInfo.connectedAt}ms, processed ${this._connectionInfo.messageCount} messages`\n      );\n      this._cleanup();\n      this.onclose?.();\n    };\n\n    this._port.onMessage.addListener(this._messageHandler);\n    this._port.onDisconnect.addListener(this._disconnectHandler);\n\n    // Start keep-alive mechanism if enabled\n    if (this._options.keepAlive) {\n      this._startKeepAlive();\n    }\n\n    console.log(\n      `[UserScriptServerTransport] Started with client: ${this._port.sender?.id || 'unknown'}`\n    );\n  }\n\n  /**\n   * Sends a message to the client\n   */\n  async send(message: JSONRPCMessage, _options?: TransportSendOptions): Promise<void> {\n    if (!this._started) {\n      throw new Error('Transport not started');\n    }\n\n    if (!this._port) {\n      throw new Error('Not connected to client');\n    }\n\n    try {\n      this._port.postMessage(message);\n    } catch (error) {\n      // Check if the error is due to disconnection\n      if (chrome.runtime.lastError || !this._port) {\n        this._cleanup();\n        this.onclose?.();\n        throw new Error('Client disconnected');\n      }\n      throw new Error(`Failed to send message: ${error}`);\n    }\n  }\n\n  /**\n   * Closes the transport\n   */\n  async close(): Promise<void> {\n    this._started = false;\n\n    if (this._port) {\n      try {\n        this._port.disconnect();\n      } catch (error) {\n        // Port might already be disconnected\n      }\n    }\n\n    this._cleanup();\n    this.onclose?.();\n  }\n\n  /**\n   * Cleans up event listeners and references\n   */\n  private _cleanup(): void {\n    // Stop keep-alive timer\n    if (this._keepAliveTimer) {\n      clearInterval(this._keepAliveTimer);\n      this._keepAliveTimer = undefined;\n    }\n\n    if (this._port) {\n      if (this._messageHandler) {\n        this._port.onMessage.removeListener(this._messageHandler);\n      }\n      if (this._disconnectHandler) {\n        this._port.onDisconnect.removeListener(this._disconnectHandler);\n      }\n    }\n  }\n\n  /**\n   * Starts the keep-alive mechanism\n   */\n  private _startKeepAlive(): void {\n    if (this._keepAliveTimer) {\n      return;\n    }\n\n    console.log(\n      `[UserScriptServerTransport] Starting keep-alive with ${this._options.keepAliveInterval}ms interval`\n    );\n\n    this._keepAliveTimer = setInterval(() => {\n      if (!this._port) {\n        this._stopKeepAlive();\n        return;\n      }\n\n      try {\n        // Send a keep-alive ping\n        this._port.postMessage({ type: 'keep-alive', timestamp: Date.now() });\n      } catch (error) {\n        console.error('[UserScriptServerTransport] Keep-alive failed:', error);\n        this._stopKeepAlive();\n      }\n    }, this._options.keepAliveInterval!) as unknown as number;\n  }\n\n  /**\n   * Stops the keep-alive mechanism\n   */\n  private _stopKeepAlive(): void {\n    if (this._keepAliveTimer) {\n      clearInterval(this._keepAliveTimer);\n      this._keepAliveTimer = undefined;\n    }\n  }\n\n  /**\n   * Gets connection information\n   */\n  getConnectionInfo() {\n    return {\n      ...this._connectionInfo,\n      uptime: Date.now() - this._connectionInfo.connectedAt,\n      isConnected: !!this._port && this._started,\n    };\n  }\n}\n"]}